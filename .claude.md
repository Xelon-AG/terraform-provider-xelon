# Xelon Terraform Provider - Claude Project Guide

## Project Overview

This is a Terraform provider for the Xelon cloud platform, built using the Terraform Plugin Framework. The provider allows users to manage Xelon cloud resources (devices, networks, firewalls, load balancers, etc.) via Terraform.

**Repository:** `terraform-provider-xelon`
**SDK Repository:** `xelon-sdk-go` (located at `../xelon-sdk-go`)
**Language:** Go
**Framework:** Terraform Plugin Framework (not the older SDK)

## Critical Project Information

### API Documentation & Preferences

**IMPORTANT:** Always use the Xelon API v2 documentation:
- **Primary API Docs:** https://api-v2-docs.mfyfe.ch/
- **Prefer v2 over v1:** When implementing features, ALWAYS check v2 API capabilities first
- **Test Environment:** http://vdctest.test/api/v2/ (requires X-User-Id header)
- **Production API:** https://hq.xelon.ch/api/v2/

### Backend Environment

- **Test Backend:** Lives at `http://vdctest.test` (local Laravel application)
- **Database:** MySQL (accessed via test environment)
- **Authentication:**
  - Bearer token via `Authorization` header
  - Client ID via `X-User-Id` header (required for test environment)

### Environment Variables

```bash
XELON_TOKEN          # API authentication token
XELON_CLIENT_ID      # Client ID for X-User-Id header
XELON_BASE_URL       # API base URL (defaults to production)
```

## Architecture

### Repository Structure

```
terraform-provider-xelon/
├── internal/provider/        # Terraform provider implementation
│   ├── provider.go          # Main provider configuration
│   ├── data_source_*.go     # Data sources
│   ├── resource_*.go        # Resources
│   └── *_test.go            # Tests
├── examples/                # Example Terraform configurations
├── docs/                    # Generated documentation
├── build/                   # Compiled provider binary
└── test-api/                # Test environment configs

xelon-sdk-go/
├── xelon/                   # SDK implementation
│   ├── client.go            # HTTP client
│   ├── *_service.go         # Service implementations
│   └── *_test.go            # Unit tests
└── go.mod
```

### SDK Design

The `xelon-sdk-go` SDK is a separate Go module that provides:
- HTTP client with authentication
- Service-oriented API (Clouds, Devices, Networks, etc.)
- Two API versions:
  - **v2 Services** (preferred): `Templates`, `Networks`, etc.
  - **v1 Services** (deprecated): `TemplatesV1`, etc.

## Development Workflow

### Building the Provider

```bash
cd terraform-provider-xelon
go build -o build/terraform-provider-xelon
```

### Testing with Local Override

Add to `~/.terraformrc`:
```hcl
provider_installation {
  dev_overrides {
    "xelon-ag/xelon" = "/Users/tonkoskurik/Sites/HQ/terraform-provider-xelon/build"
  }
  direct {}
}
```

### Running Tests

```bash
# SDK tests
cd xelon-sdk-go
go test -v ./xelon

# Provider tests
cd terraform-provider-xelon
go test -v ./internal/provider

# Integration test with Terraform
cd test-api
terraform plan
```

## Implementation Guidelines

### 1. Always Check API v2 Documentation First

Before implementing any feature:
1. ✅ Check https://api-v2-docs.mfyfe.ch/ for endpoint capabilities
2. ✅ Review available query parameters (filters, pagination, search, etc.)
3. ✅ Design SDK methods to utilize ALL relevant API parameters
4. ✅ Optimize for performance from the start (use `perPage=100`, server-side filters, etc.)
5. ❌ Don't blindly copy v1 patterns - they may be inefficient

### 2. API Parameter Utilization

When creating SDK methods for list endpoints, ALWAYS support these common v2 parameters:
- `page` - Pagination (handle automatically)
- `perPage` - Items per page (default: 100 for efficiency)
- `sort` - Sorting field
- `search` - Text search (server-side filtering)
- Specific filters (e.g., `cloudIdentifier`, `type`, `isActive`)

**Example Pattern:**
```go
type ResourceListOptions struct {
    Page       int      `url:"page,omitempty"`
    PerPage    int      `url:"perPage,omitempty"`
    Sort       string   `url:"sort,omitempty"`
    Search     string   `url:"search,omitempty"`
    // Resource-specific filters
    CloudIdentifier string `url:"cloudIdentifier,omitempty"`
    Type           string  `url:"type,omitempty"`
}

func (s *Service) List(ctx context.Context, opts *ResourceListOptions) ([]Resource, *Response, error) {
    if opts == nil {
        opts = &ResourceListOptions{}
    }
    if opts.PerPage == 0 {
        opts.PerPage = 100 // Max per page for efficiency
    }

    // Build URL with all parameters
    path, err := addOptions("endpoint", opts)
    // ... handle pagination, accumulate results
}
```

### 3. Provider Data Source Pattern

When implementing data sources:
```go
func (d *dataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
    // 1. Build SDK options with server-side filters
    opts := &xelon.ListOptions{
        PerPage: 100,
        Sort:    "name",
    }

    // 2. Add filters from Terraform config
    if !data.Filter.IsNull() {
        opts.FilterField = data.Filter.ValueString()
    }

    // 3. Use search parameter when applicable
    if name != "" {
        opts.Search = name
    }

    // 4. Call SDK with options
    results, _, err := d.client.Service.List(ctx, opts)

    // 5. Find exact match in filtered results
    // (API may return partial matches)
}
```

### 4. Testing Requirements

Every SDK service method should have:
- ✅ Unit test with mock HTTP server
- ✅ Test for query parameter construction
- ✅ Test for pagination handling
- ✅ Test for error cases

Every provider resource/data source should have:
- ✅ Basic CRUD tests
- ✅ Integration test in `test-api/` directory

### 5. API v2 Response Structure

Most v2 endpoints return paginated responses:
```json
{
  "data": [
    { "identifier": "...", "name": "...", ... }
  ],
  "meta": {
    "total": 100,
    "lastPage": 10,
    "perPage": 10,
    "currentPage": 1,
    "from": 1,
    "to": 10
  }
}
```

**Key differences from v1:**
- `identifier` (string UUID) instead of `id` (integer)
- Flat structure with `cloudIdentifier` instead of nested `hv_system.id`
- Pagination metadata in `meta` field
- All items in `data` array (no separate `templates_linux`, `templates_windows`, etc.)

## Performance Best Practices

### DO:
- ✅ Use `perPage=100` to minimize API calls
- ✅ Use server-side filtering (cloudIdentifier, type, search, etc.)
- ✅ Use `search` parameter for name-based lookups
- ✅ Let API defaults apply (don't send unnecessary parameters)
- ✅ Handle pagination automatically in SDK

### DON'T:
- ❌ Fetch all items then filter client-side (use API filters!)
- ❌ Use default `perPage=10` (wastes API calls)
- ❌ Skip available query parameters
- ❌ Assume old v1 patterns are optimal

## Common Patterns

### API Client Configuration

```go
import "github.com/Xelon-AG/xelon-sdk-go/xelon"

client := xelon.NewClient(
    token,
    xelon.WithBaseURL("http://vdctest.test/api/v2/"),
    xelon.WithClientID(clientID),
)
```

### Resource Identifiers

- **v2 API uses string identifiers:** `"0b8e53f7147a"` (UUIDs/hashes)
- **v1 API used integers:** `12345`
- Always use `types.String` in Terraform schemas for IDs

### Authentication Headers

The SDK automatically sets:
```http
Authorization: Bearer <token>
X-User-Id: <client_id>
Accept: application/json
Content-Type: application/json
```

## Debugging

### Enable Provider Logging

```bash
TF_LOG=DEBUG terraform plan
TF_LOG_PROVIDER=DEBUG terraform plan
```

### Common Issues

1. **"invalid character '<' looking for beginning of value"**
   - API returned HTML error page instead of JSON
   - Check authentication (token, client ID)
   - Verify endpoint URL is correct

2. **"422 validation error on isActive"**
   - Don't send boolean as string
   - Let API use defaults when possible

3. **Templates array is nil**
   - You're using v1 SDK with v2 API
   - Use `client.Templates` (v2) not `client.TemplatesV1`

## Related Documentation

- Terraform Plugin Framework: https://developer.hashicorp.com/terraform/plugin/framework
- Go SDK Documentation: https://pkg.go.dev/github.com/Xelon-AG/xelon-sdk-go
- Xelon API v2 Docs: https://api-v2-docs.mfyfe.ch/

## Quick Reference

### Useful Commands

```bash
# Build provider
go build -o build/terraform-provider-xelon

# Run SDK tests
cd ../xelon-sdk-go && go test -v ./xelon

# Run provider tests
go test -v ./internal/provider

# Test with real API
cd test-api && terraform plan

# Check for breaking changes
go test -v -run TestProviderSchema
```

### Key Files

- `internal/provider/provider.go` - Provider configuration
- `xelon-sdk-go/xelon/client.go` - SDK client setup
- `test-api/test-datasources.tf` - Integration tests
- `examples/` - User-facing examples

## Questions to Ask Before Implementation

When implementing a new feature, always ask:

1. ✅ What does the v2 API documentation say about this endpoint?
2. ✅ What query parameters are available for filtering/searching?
3. ✅ What's the pagination behavior? (page size, total count, etc.)
4. ✅ What's the response structure? (data array, meta object, field names)
5. ✅ Are identifiers strings (v2) or integers (v1)?
6. ✅ Can we use server-side filtering instead of client-side?
7. ✅ What's the optimal `perPage` value?
8. ✅ Does the API have rate limits we should consider?

## Project Conventions (ALWAYS FOLLOW THESE!)

### Naming Conventions

**File Naming:**
```
data_source_<resource>.go       # Data source implementations
data_source_<resource>_test.go  # Data source tests
resource_xelon_<resource>.go    # Resource implementations
resource_xelon_<resource>_test.go # Resource tests
<service>.go                    # SDK service implementations (networks.go, devices.go)
<service>_test.go               # SDK tests
```

**Type Naming:**
```go
// Provider/Terraform side
type networkDataSource struct { ... }          // Data source
type networkDataSourceModel struct { ... }     // Data source model
type sshKeyResource struct { ... }             // Resource
type sshKeyResourceModel struct { ... }        // Resource model

// SDK side
type NetworksService service                   // Service
type Network struct { ... }                    // Main type
type NetworkLANCreateRequest struct { ... }    // Create request
type NetworkLANUpdateRequest struct { ... }    // Update request
type NetworkListOptions struct { ... }         // List options
type networkRoot struct { ... }                // Single item response wrapper (private)
type networksRoot struct { ... }               // List response wrapper (private)
```

**Variable/Field Naming:**
```go
// Go code: camelCase
networkID := "123"
dnsSecondary := "8.8.4.4"

// Struct tags: snake_case
type Model struct {
    DNSPrimary types.String `tfsdk:"dns_primary"`  // NOT dnsPrimary or DNSPrimary
    CloudID    types.String `tfsdk:"cloud_id"`     // NOT cloudId or cloudID
}

// JSON tags: match API exactly (varies)
type Network struct {
    DNSPrimary string `json:"dns1"`              // API uses "dns1"
    SubnetSize int    `json:"networkSize"`       // API uses "networkSize"
}
```

### Code Structure Conventions

**Data Source Pattern:**
```go
package provider

import (
    "context"
    // ... standard imports first
    // ... hashicorp imports
    // ... xelon SDK last
)

var (
    // Interface assertions at top
    _ datasource.DataSource              = (*resourceDataSource)(nil)
    _ datasource.DataSourceWithConfigure = (*resourceDataSource)(nil)
)

// Type definitions
type resourceDataSource struct {
    client *xelon.Client
}

type resourceDataSourceModel struct {
    // Fields in alphabetical order
    ID   types.String `tfsdk:"id"`
    Name types.String `tfsdk:"name"`
}

// Constructor
func NewResourceDataSource() datasource.DataSource {
    return &resourceDataSource{}
}

// Methods in order: Metadata, Schema, Configure, Read
func (d *resourceDataSource) Metadata(...) { ... }
func (d *resourceDataSource) Schema(...) { ... }
func (d *resourceDataSource) Configure(...) { ... }
func (d *resourceDataSource) Read(...) { ... }
```

**Resource Pattern:**
```go
var (
    _ resource.Resource                = (*resourceResource)(nil)
    _ resource.ResourceWithConfigure   = (*resourceResource)(nil)
    _ resource.ResourceWithImportState = (*resourceResource)(nil)
)

// Methods in order: Metadata, Schema, Configure, Create, Read, Update, Delete, ImportState
```

**SDK Service Pattern:**
```go
const resourceBasePath = "resources"

type ResourcesService service

type Resource struct { ... }

type ResourceCreateRequest struct { ... }

type ResourceListOptions struct {
    Sort   string `url:"sort,omitempty"`
    Search string `url:"search,omitempty"`
    ListOptions  // Embed common options
}

type resourceRoot struct {
    Resource *Resource `json:"data,omitempty"`
}

type resourcesRoot struct {
    Resources []Resource `json:"data"`
    Meta      *Meta      `json:"meta,omitempty"`
}

// Methods in order: List, Get, Create, Update, Delete
// Always check for nil/empty parameters
func (s *ResourcesService) Get(ctx context.Context, id string) (*Resource, *Response, error) {
    if id == "" {
        return nil, nil, errors.New("failed to get resource: id must be supplied")
    }
    // ...
}
```

### Error Message Conventions

**Provider errors:**
```go
response.Diagnostics.AddError(
    "Missing required attributes",           // Title: Short, capitalized
    `The attribute "id" or "name" must be defined.`,  // Detail: Full sentence with backticks for code
)

response.Diagnostics.AddError(
    "Ambiguous search result",
    fmt.Sprintf("Specified and actual network name are different: expected '%s', got '%s'.", expected, actual),
)

response.Diagnostics.AddError(
    "No search results",
    "Please refine your search.",
)

response.Diagnostics.AddError(
    "Unable to get network",      // Use "Unable to..." for API errors
    err.Error(),
)
```

**SDK errors:**
```go
return nil, nil, errors.New("failed to get network: id must be supplied")
return nil, nil, fmt.Errorf("failed to create network: %w", err)
```

### Logging Conventions

**Use tflog with structured context:**
```go
tflog.Info(ctx, "Searching for network by ID", map[string]any{"network_id": networkID})
tflog.Debug(ctx, "Getting network", map[string]any{"network_id": networkID})
tflog.Debug(ctx, "Got network", map[string]any{"data": network, "network_id": networkID})
```

**Logging levels:**
- `Info`: User actions (searching, creating, updating)
- `Debug`: API calls and responses
- `Trace`: Internal logic flow (rarely used)

### Schema Documentation Conventions

**Always use MarkdownDescription:**
```go
"id": schema.StringAttribute{
    MarkdownDescription: "The ID of the network.",  // Start with "The", end with period
    Computed:            true,
    Optional:            true,
},

"type": schema.StringAttribute{
    MarkdownDescription: "The type of the network (`LAN` or `WAN`).",  // Use backticks for values
    Computed:            true,
},

schema.Schema{
    MarkdownDescription: `
The network resource allows you to manage Xelon networks.

You can create LAN and WAN networks for connecting your devices.
`,  // Multi-line for resource/data source descriptions
    Attributes: map[string]schema.Attribute{ ... },
}
```

### Data Enrichment Pattern

**List endpoints often return partial data - enrich with Get:**
```go
// 1. Search by name using List
networks, _, err := d.client.Networks.List(ctx, &xelon.NetworkListOptions{Search: networkName})

// 2. Check results
if len(networks) == 0 {
    return // no results
}
if len(networks) > 1 {
    return // too many results
}

// 3. Enrich with Get (list may not include all fields)
network := &networks[0]
network, _, err = d.client.Networks.Get(ctx, network.ID)
```

### Import Ordering

```go
import (
    // 1. Standard library
    "context"
    "fmt"
    "net/http"

    // 2. External dependencies (alphabetical)
    "github.com/hashicorp/terraform-plugin-framework/datasource"
    "github.com/hashicorp/terraform-plugin-framework/types"
    "github.com/hashicorp/terraform-plugin-log/tflog"

    // 3. Internal/SDK (last)
    "github.com/Xelon-AG/xelon-sdk-go/xelon"
)
```

### Testing Conventions

**Test naming:**
```go
func TestResourceName_Method(t *testing.T) { ... }
func TestNetworksService_List(t *testing.T) { ... }
func TestNetworksService_List_WithFilters(t *testing.T) { ... }
```

**Test structure:**
```go
func TestSomething(t *testing.T) {
    // 1. Setup mock server
    server := httptest.NewServer(...)
    defer server.Close()

    // 2. Create client
    client := xelon.NewClient("test-token", xelon.WithBaseURL(server.URL+"/"))

    // 3. Call method
    result, _, err := client.Service.Method(context.Background(), opts)

    // 4. Assertions
    if err != nil {
        t.Fatalf("Method returned error: %v", err)
    }
    if result.Field != expected {
        t.Errorf("Expected %s, got %s", expected, result.Field)
    }
}
```

### Common Patterns to Follow

**ID or Name lookup:**
```go
resourceID := data.ID.ValueString()
resourceName := data.Name.ValueString()

if resourceID == "" && resourceName == "" {
    response.Diagnostics.AddError(
        "Missing required attributes",
        `The attribute "id" or "name" must be defined.`,
    )
    return
}

if resourceID != "" {
    // Lookup by ID
    resource, resp, err := d.client.Service.Get(ctx, resourceID)
    if err != nil {
        if resp != nil && resp.StatusCode == http.StatusNotFound {
            response.Diagnostics.AddError("No search results", "Please refine your search.")
            return
        }
        response.Diagnostics.AddError("Unable to get resource", err.Error())
        return
    }

    // Verify name if provided
    if resourceName != "" && resourceName != resource.Name {
        response.Diagnostics.AddError(
            "Ambiguous search result",
            fmt.Sprintf("Specified and actual name are different: expected '%s', got '%s'.", resourceName, resource.Name),
        )
        return
    }
} else {
    // Lookup by name (use search parameter)
    resources, _, err := d.client.Service.List(ctx, &xelon.ListOptions{Search: resourceName})
    // ... handle results
}
```

**Mapping SDK types to Terraform types:**
```go
// Always use types.StringValue, types.Int64Value, etc.
data.ID = types.StringValue(resource.ID)
data.Name = types.StringValue(resource.Name)
data.Count = types.Int64Value(int64(resource.Count))

// Handle optional/pointer fields
if resource.Owner != nil {
    data.TenantID = types.StringValue(resource.Owner.ID)
}

// Handle nested objects
var clouds []cloudModel
for _, cloud := range network.Clouds {
    clouds = append(clouds, cloudModel{
        ID:   types.StringValue(cloud.ID),
        Name: types.StringValue(cloud.Name),
    })
}
data.Clouds = clouds
```

### Anti-Patterns (DON'T DO THIS!)

❌ **Don't use inline struct tags:**
```go
// BAD
data.ID = data.Get("id")

// GOOD
data.ID = types.StringValue(resource.ID)
```

❌ **Don't skip parameter validation in SDK:**
```go
// BAD
func (s *Service) Get(ctx context.Context, id string) (*Resource, *Response, error) {
    path := fmt.Sprintf("resources/%s", id)  // What if id is empty?
}

// GOOD
func (s *Service) Get(ctx context.Context, id string) (*Resource, *Response, error) {
    if id == "" {
        return nil, nil, errors.New("failed to get resource: id must be supplied")
    }
    path := fmt.Sprintf("resources/%s", id)
}
```

❌ **Don't create inconsistent error messages:**
```go
// BAD - inconsistent wording
"Could not find network"
"Network retrieval failed"
"Unable to get network"

// GOOD - consistent pattern
"Unable to get network"
"Unable to create network"
"Unable to delete network"
```

❌ **Don't forget to check HTTP status codes:**
```go
// BAD
resource, _, err := client.Service.Get(ctx, id)
if err != nil {
    return err  // Could be 404, 500, network error, etc.
}

// GOOD
resource, resp, err := client.Service.Get(ctx, id)
if err != nil {
    if resp != nil && resp.StatusCode == http.StatusNotFound {
        // Handle 404 specifically
    }
    return err
}
```

## Notes

- **Always prefer v2 API over v1** - v1 is deprecated
- **Test environment database must be running** for integration tests
- **Provider uses Terraform Plugin Framework** (not legacy SDK)
- **SDK is separate repository** - changes require updates in both repos
- **Follow existing patterns** - consistency is more important than personal preference
